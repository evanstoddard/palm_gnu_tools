/* DO NOT EDIT!
   This file was automatically generated by @progname@
   from @deffile@  */

struct LibRef;
static struct LibRef *libref = 0;

extern void GLibClose(struct LibRef *);

#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
/* Recent versions of prc-tools's GCC use %a4 or %a5 depending on -mown-gp.  */
    #ifdef __OWNGP__
    #define A4_GLOBALS
    #else
    #undef A4_GLOBALS
    #endif
#else
/* The prc-tools 0.5.0 version always uses %a4.  */
#define A4_GLOBALS
#endif

void GLib_@crid@(void)
{
#ifdef A4_GLOBALS
    asm volatile (".equ A4_GLOBALS,1");
#endif

    asm volatile ("
@-function-jumps-@

libname:
    .asciz \"@libname@\"
    .even

dispatch:
    lea libname(%%pc),%%a1
    move.l %%a1,%%d2

    .ifdef A4_GLOBALS
    move.l %%a4,%%d1
    move.l %%d1,%%d1
    jbeq noglobals
    .endif

    lea %0,%%a1
noglobals:
    move.l %1,%%d1
    braw GLibDispatch
    " : : "g" (libref), "i" ('@crid@') );
}

#ifdef A4_GLOBALS

/* The 0.5.0 distribution didn't use a .dtors section.  In order to
   be usable with that compiler, we use a .ehook function and check
   for globals ourselves.  */

register void *reg_a4 asm("%a4");

static void
GLib_@crid@_clean(unsigned short cmd, void *PBP, unsigned short flags)
{
    if (reg_a4 && libref) {
	GLibClose(libref);
	libref = 0;
    }
}

static void *hook
  __attribute__ ((section ("ehook"), unused)) = GLib_@crid@_clean;

#else

static void __attribute__ ((destructor, unused))
GLib_@crid@_clean()
{
    if (libref) {
	GLibClose(libref);
	libref = 0;
    }
}

#endif
