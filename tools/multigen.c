/* multigen.c: generate a multiple section stub file and linker script from
   a .def file.

   Copyright (c) 1999-2000 Palm Computing, Inc. or its subsidiaries.
   All rights reserved.

   This is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"
#include "utils.h"
#include "def.h"

const char* version = "1.1";

void
usage() {
  printf ("\
Usage: %s [options] deffile\n\
Creates assembly stub file `<base>.s' and linker script `<base>.ld' from\n\
multiple code clause in <deffile>; <base> is `<deffile>-sections' by default.\n\
Options:\n", progname);
  propt ("-b FILE, --base FILE", "Set output filename base prefix");
  }

enum {
  OPTION_HELP = 150,
  OPTION_VERSION
  };

char* shortopts = "b:";

struct option longopts[] = {
  { "base", required_argument, NULL, 'b' },
  { "help", no_argument, NULL, OPTION_HELP },
  { "version", no_argument, NULL, OPTION_VERSION },
  { NULL, no_argument, NULL, 0 }
  };

#ifdef __GNUC__
#define UNUSED_PARAM  __attribute__ ((unused))
#else
#define UNUSED_PARAM
#endif

struct section_entry {
  const char *name;
  struct section_entry *next;
  };

static struct section_entry *first_section_entry = NULL;
static struct section_entry **next_section_entry_ptr = &first_section_entry;

static void
section (const char *secname) {
  struct section_entry *entry = malloc (sizeof (struct section_entry));
  entry->name = secname;
  entry->next = NULL;
  *next_section_entry_ptr = entry;
  next_section_entry_ptr = &entry->next;
  }

void
write_stub_file (FILE *f, const char *fname) {
  struct section_entry main_section, *entry;
  int n;

  fprintf (f, "\t.file\t\"%s\"\n\n", fname);

  main_section.name = "";
  main_section.next = first_section_entry;

  for (entry = &main_section, n = 0; entry; entry = entry->next, n++) {
    fprintf (f, "\t.globl\t__text__%s\n", entry->name);
    fprintf (f, "\t.lcomm\t__text__%s,4\n", entry->name);
    }

  fprintf (f, "\
\n\
\t.globl\t__code_section_count\n\
\t.equ\t__code_section_count,%d\n\
\n\
.text\n\
\t.globl\t_GccRelocateData\n\
_GccRelocateData:\n\
\tbra.w\t_GccLoadCodeAndRelocateData\n\
\n\
.section ehook\n\
\t.long\t_GccReleaseCode\n", n);
  }

void
write_linker_script (FILE *f, const char *fname UNUSED_PARAM) {
  struct section_entry *entry;

  fprintf (f, "MEMORY\n{\n");

  for (entry = first_section_entry; entry; entry = entry->next)
    fprintf (f, "\t%sres : ORIGIN = 0x0, LENGTH = 32768\n", entry->name);

  fprintf (f, "}\n\nSECTIONS\n{\n");

  for (entry = first_section_entry; entry; entry = entry->next)
    fprintf (f, "\t%s : { *(%s) } > %sres\n",
	     entry->name, entry->name, entry->name);

  fprintf (f, "}\n");
  }

void
generate_file (const char *fname, const char *deffname,
	       void (*writer_fn)(FILE *f, const char *fname)) {
  FILE *f = fopen (fname, "w");

  if (f == NULL) {
    einfo (E_NOFILE | E_PERROR, "can't create `%s'", fname);
    return;
    }

  fprintf (f, "\
/* DO NOT EDIT!\n\
   This file was automatically generated by %s\n\
   from %s  */\n\n", progname, deffname);

  writer_fn (f, fname);

  if (fclose (f) != 0) {
    einfo (E_NOFILE | E_PERROR, "can't close `%s'", fname);
    remove (fname);
    }
  }

int
main (int argc, char **argv) {
  int c, longind;
  int work_desired = 1;
  char *outfbase = NULL;

  struct def_callbacks funcs = default_def_callbacks;
  funcs.multicode_section = section;

  progname = argv[0];

  while ((c = getopt_long (argc, argv, shortopts, longopts, &longind)) != -1)
    switch (c) {
    case 'b':
      outfbase = optarg;
      break;

    case OPTION_HELP:
      usage ();
      work_desired = 0;
      break;

    case OPTION_VERSION:
      printf ("%s version %s\n", progname, version);
      work_desired = 0;
      break;
      }

  if (!work_desired)
    return 0;

  if (optind + 1 != argc) {
    usage ();
    return 0;
    }

  read_def_file (argv[optind], &funcs);

  if (first_section_entry == NULL)
    einfo (E_FILE | E_WARNING, "no multiple code sections specified");

  if (nerrors == 0) {
    char buffer[FILENAME_MAX];
    char *outfname, *eos;

    if (outfbase) {
      strcpy (buffer, outfbase);
      outfname = buffer;
      }
    else {
      strcpy (buffer, argv[optind]);
      outfname = basename_with_changed_extension (buffer, "-sections");
      }

    eos = strchr (outfname, '\0');

    strcpy (eos, ".s");
    generate_file (outfname, argv[optind], write_stub_file);

    strcpy (eos, ".ld");
    generate_file (outfname, argv[optind], write_linker_script);
    }

  return (nerrors == 0)? EXIT_SUCCESS : EXIT_FAILURE;
  }
