/* stubgen.c: generate a library dispatch stub file from a .def file.

   Copyright (c) 1999 Palm Computing, Inc. or its subsidiaries.
   All rights reserved.

   This is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"
#include "utils.h"
#include "def.h"

const char* version = "1.0";

void
usage() {
  printf ("Usage: %s [-o outputfile] deffile\n", progname);
  }

enum {
  OPTION_HELP = 150,
  OPTION_VERSION
  };

char* shortopts = "o:";

struct option longopts[] = {
  { "output", required_argument, NULL, 'o' },
  { "help", no_argument, NULL, OPTION_HELP },
  { "version", no_argument, NULL, OPTION_VERSION },
  { NULL, no_argument, NULL, 0 }
  };

#ifdef __GNUC__
#define UNUSED_PARAM __attribute__ ((unused))
#endif

static int nsections, multiple_code_present;
static FILE *outf;

static void
db_header (enum database_kind kind, const struct database_header *h) {
  /* is it a glib or a syslib? */
  }

static void
section (const char *secname) {
  fprintf (outf, "\t.globl\t__text__%s\n", secname);
  fprintf (outf, "\t.lcomm\t__text__%s,4\n", secname);
  nsections++;
  }

static void
multiple_code (int n UNUSED_PARAM) {
  multiple_code_present = 1;
  }

void
generate (const char *outfname, const char *infname) {
  struct def_callbacks funcs;
  char tempfname[L_tmpnam];

  tmpnam (tempfname);
  if ((outf = fopen (tempfname, "w")) == NULL) {
    einfo (E_NOFILE | E_PERROR, "can't create temporary file `%s'", tempfname);
    return;
    }

  fprintf (outf, "/* NEED TO IMPLEMENT THIS!!!! */\n");

  fprintf (outf, "\
/* DO NOT EDIT!\n\
   This file was automatically generated by %s\n\
   from %s  */\n\
\n\
\t.file\t\"%s\"\n\
\n", progname, infname, outfname);

  nsections = 0;
  multiple_code_present = 0;

  funcs = default_def_callbacks;
  funcs.db_header = db_header;
  funcs.multicode = multiple_code;
  funcs.multicode_section = section;

  section ("");
  read_def_file (infname, &funcs);
  
  if (!multiple_code_present)
    einfo (E_FILE, "missing multiple code clause");

  fprintf (outf, "\
\n\
\tmake a big error message here!\n\
\t.globl\t__code_section_count\n\
\t.equ\t__code_section_count,%d\n\
\n\
.text\n\
\t.globl\t_GccRelocateData\n\
_GccRelocateData:\n\
\tbra.w\t_GccLoadCodeAndRelocateData\n\
\n\
.section ehook\n\
\t.long\t_GccReleaseCode\n", nsections);

  fclose (outf);

  if (nerrors == 0)
    copy_file (outfname, tempfname, "");

  remove (tempfname);
  }

int
main (int argc, char **argv) {
  int c, longind;
  int work_desired = 1;
  char *outfname = NULL;

  progname = argv[0];

  while ((c = getopt_long (argc, argv, shortopts, longopts, &longind)) != -1)
    switch (c) {
    case 'o':
      outfname = optarg;
      break;

    case OPTION_HELP:
      usage ();
      work_desired = 0;
      break;

    case OPTION_VERSION:
      printf ("%s version %s\n", progname, version);
      work_desired = 0;
      break;
      }

  if (!work_desired)
    return 0;

  if (optind + 1 != argc) {
    usage ();
    return 0;
    }

  if (outfname == NULL) {
    static char name[FILENAME_MAX];
    char *s, *dot;

    strcpy (name, argv[optind]);

    /* Find the last dot in the filename (not the directories!).  */
    dot = NULL;
    for (s = name; *s; s++)
      if (*s == '.')  dot = s;
      else if (*s == '/' || *s =='\\')  dot = NULL;

    if (dot)  strcpy (dot, "-jumps.s");
    else  strcat (name, "-jumps.s");

    outfname = name;
    }

  generate (outfname, argv[optind]);
  return (nerrors == 0)? EXIT_SUCCESS : EXIT_FAILURE;
  }
