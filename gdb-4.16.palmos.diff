diff -urN orig/gdb-4.16/gdb/ChangeLog gdb-4.16/gdb/ChangeLog
--- orig/gdb-4.16/gdb/ChangeLog	Tue Apr 23 00:34:43 1996
+++ gdb-4.16/gdb/ChangeLog	Sat Jun 14 13:27:07 1997
@@ -1,3 +1,25 @@
+Sun Apr 27 20:42:12 1997  Kenneth Albanowski  <kjahds@kjahds.com>
+	* config/m68k/tm-m68kpalmos.h: ints are 16 bits, registers 32
+	* remote-palmos.c: write_memory now works
+
+Fri Mar 28 16:32:13 1997  Kenneth Albanowski  <kjahds@kjahds.com>
+
+	* remote-palmos.c config/m68k/m68kpalmos.mt: Removed
+	dependency on pilot-link library.
+	* ser-unix.c: added support for baud rates above 38400
+
+Sun Mar 23 17:14:35 1997  Kenneth Albanowski  <kjahds@kjahds.com>
+
+	* *palmos*: Renamed to *m68kpalmos*
+	* remote-palmos.c: New file.
+
+Wed Mar  5 21:41:51 1997  Kresten Krab Thorup  <krab@california.daimi.aau.dk>
+
+	* config/m68k/palmos.mt, config/m68k/tm-palmos.h: New files.
+
+	* m68k-tdep.c (m68k_saved_pc_after_call): Added support for
+	MAC_SYSCALL_TRAP style systraps.
+
 Mon Apr 22 20:17:01 1996  Fred Fish  <fnf@cygnus.com>
 
 	* Makefile.in (VERSION): Bump version number to 4.16
diff -urN orig/gdb-4.16/gdb/Makefile.in gdb-4.16/gdb/Makefile.in
--- orig/gdb-4.16/gdb/Makefile.in	Tue Apr 23 00:43:08 1996
+++ gdb-4.16/gdb/Makefile.in	Sat Jun 14 13:27:07 1997
@@ -873,7 +873,7 @@
 	procfs.c pyr-tdep.c pyr-xdep.c \
 	remote-adapt.c remote-array.c remote-bug.c remote-e7000.c remote-eb.c \
 	remote-es.c remote-hms.c remote-mips.c \
-	remote-mm.c remote-nindy.c remote-os9k.c remote-rdp.c remote-sim.c \
+	remote-mm.c remote-nindy.c remote-os9k.c remote-palmos.c remote-rdp.c remote-sim.c \
 	remote-st.c remote-utils.c dcache.c \
 	remote-udi.c remote-vx.c remote-vx29k.c \
 	rs6000-nat.c rs6000-tdep.c \
@@ -1337,6 +1337,10 @@
 	symfile.h
 
 remote-os9k.o: remote-os9k.c $(defs_h) $(gdbcore_h) $(wait_h) \
+	$(command_h) monitor.h $(remote_utils_h) $(symtab_h) symfile.h \
+	objfiles.h gdb-stabs.h gdb_string.h
+
+remote-palmos.o: remote-palmos.c $(defs_h) $(gdbcore_h) $(wait_h) \
 	$(command_h) monitor.h $(remote_utils_h) $(symtab_h) symfile.h \
 	objfiles.h gdb-stabs.h gdb_string.h
 
diff -urN orig/gdb-4.16/gdb/config/m68k/m68kpalmos.mt gdb-4.16/gdb/config/m68k/m68kpalmos.mt
--- orig/gdb-4.16/gdb/config/m68k/m68kpalmos.mt	Wed Dec 31 19:00:00 1969
+++ gdb-4.16/gdb/config/m68k/m68kpalmos.mt	Sat Jun 14 13:35:03 1997
@@ -0,0 +1,6 @@
+# Target: Motorola 680x0 running PalmOS
+TDEPFILES= coff-solib.o m68k-tdep.o
+
+TM_FILE= tm-m68kpalmos.h
+
+REMOTE_OBS = dcache.o remote-palmos.o remote.o
diff -urN orig/gdb-4.16/gdb/config/m68k/tm-m68kpalmos.h gdb-4.16/gdb/config/m68k/tm-m68kpalmos.h
--- orig/gdb-4.16/gdb/config/m68k/tm-m68kpalmos.h	Wed Dec 31 19:00:00 1969
+++ gdb-4.16/gdb/config/m68k/tm-m68kpalmos.h	Sat Jun 14 13:27:07 1997
@@ -0,0 +1,56 @@
+/* Target machine definitions for m68k PalmOS.
+   Copyright (C) 1986, 1987, 1989, 1993, 1995 Free Software Foundation, Inc.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* The definitions here are appropriate for several embedded m68k-based
+   targets, including IDP (rom68k), BCC (cpu32bug), and EST's emulator.  */
+
+/* GCC is probably the only compiler used on this configuration.  So
+   get this right even if the code which detects gcc2_compiled. is
+   still broken.  */
+
+#define BELIEVE_PCC_PROMOTION 1
+
+/* The target system handles breakpoints.  */
+
+#define DECR_PC_AFTER_BREAK 2
+
+/* No float registers.  */
+
+/*#define NUM_REGS 18*/
+
+#include "m68k/tm-m68k.h"
+
+#define TARGET_INT_BIT 16
+#define TARGET_PTR_BIT 32
+
+#undef REGISTER_VIRTUAL_TYPE
+#define REGISTER_VIRTUAL_TYPE(N)                                \
+ (((unsigned)(N) - FP0_REGNUM) < 8 ? builtin_type_double :      \
+ (N) == PC_REGNUM || (N) == FP_REGNUM || (N) == SP_REGNUM ?     \
+ lookup_pointer_type (builtin_type_void) : builtin_type_long)
+
+/* FIXME, should do GET_LONGJMP_TARGET for newlib.  */
+
+#ifdef __GNUC__
+#define MAC_SYSCALL_TRAP \
+   ({ static long addr = 0; \
+      addr != 0 ? addr : (addr = read_memory_integer ((32+15)*4, 4)); })
+#else
+#define MAC_SYSCALL_TRAP read_memory_integer ((32+15)*4, 4)
+#endif
diff -urN orig/gdb-4.16/gdb/configure gdb-4.16/gdb/configure
--- orig/gdb-4.16/gdb/configure	Tue Apr 23 00:34:51 1996
+++ gdb-4.16/gdb/configure	Sat Jun 14 13:27:07 1997
@@ -2069,6 +2069,7 @@
 m68*-monitor-*)         gdb_target=monitor ;;
 m68*-est-*)		gdb_target=monitor ;;
 m68*-*-aout*)		gdb_target=monitor ;;
+m68*-palmos-coff*)              gdb_target=m68kpalmos ;;
 m68*-*-coff*)		gdb_target=monitor ;;
 m68*-*-elf*)		gdb_target=monitor ;;
 m68*-*-lynxos*)		gdb_target=m68klynx
diff -urN orig/gdb-4.16/gdb/configure.in gdb-4.16/gdb/configure.in
--- orig/gdb-4.16/gdb/configure.in	Tue Apr 23 00:34:51 1996
+++ gdb-4.16/gdb/configure.in	Sat Jun 14 13:27:07 1997
@@ -385,6 +385,7 @@
 m68*-bull-sysv*)	gdb_target=dpx2 ;;
 m68*-hp-bsd*)		gdb_target=hp300bsd ;;
 m68*-hp-hpux*)		gdb_target=hp300hpux ;;
+m68*-palmos-coff*)		gdb_target=m68kpalmos ;;
 m68*-altos-*)		gdb_target=altos ;;
 m68*-att-*)		gdb_target=3b1 ;;
 m68*-cisco*-*)		gdb_target=cisco ;;
diff -urN orig/gdb-4.16/gdb/m68k-tdep.c gdb-4.16/gdb/m68k-tdep.c
--- orig/gdb-4.16/gdb/m68k-tdep.c	Tue Aug  1 23:19:07 1995
+++ gdb-4.16/gdb/m68k-tdep.c	Sat Jun 14 13:27:07 1997
@@ -504,6 +504,11 @@
     return read_memory_integer (read_register (SP_REGNUM) + 4, 4);
   else
 #endif /* SYSCALL_TRAP */
+#ifdef MAC_SYSCALL_TRAP
+  if (frame->pc == MAC_SYSCALL_TRAP)
+    return read_memory_integer (read_register (SP_REGNUM) + 2, 4) + 2;
+  else
+#endif /* MAC_SYSCALL_TRAP */
     return read_memory_integer (read_register (SP_REGNUM), 4);
 }
 
diff -urN orig/gdb-4.16/gdb/remote-palmos.c gdb-4.16/gdb/remote-palmos.c
--- orig/gdb-4.16/gdb/remote-palmos.c	Wed Dec 31 19:00:00 1969
+++ gdb-4.16/gdb/remote-palmos.c	Mon Jun 16 23:16:26 1997
@@ -0,0 +1,1159 @@
+/* Remote target communications for serial-line targets in custom GDB protocol
+   Copyright 1988, 1991, 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
+   
+   Written by Kenneth Albanowski <kjahds@kjahds.com>, derived (with
+   assistance from Palm Computing, Inc.) from work by
+   
+     Kenneth Albanowski,
+     Donald Jeff Dionne <jeff@RyeHam.ee.ryerson.ca>,
+     Kresten Krab Thorup <krab@daimi.aau.dk>,
+     and whoever wrote remote.c and xmodem.c.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "gdb_string.h"
+#include <fcntl.h>
+#include "frame.h"
+#include "inferior.h"
+#include "bfd.h"
+#include "symfile.h"
+#include "target.h"
+#include "wait.h"
+/*#include "terminal.h"*/
+#include "gdbcmd.h"
+#include "objfiles.h"
+#include "gdb-stabs.h"
+#include "thread.h"
+
+#include "dcache.h"
+
+#ifdef USG
+#include <sys/types.h>
+#endif
+
+#include <signal.h>
+#include "serial.h"
+#include "xmodem.h"
+
+/* Prototypes for local functions */
+
+static int remote_write_bytes PARAMS ((CORE_ADDR memaddr,
+				       char *myaddr, int len));
+
+static int remote_read_bytes PARAMS ((CORE_ADDR memaddr,
+				      char *myaddr, int len));
+
+static void remote_files_info PARAMS ((struct target_ops *ignore));
+
+static int remote_xfer_memory PARAMS ((CORE_ADDR memaddr, char *myaddr,
+				       int len, int should_write,
+				       struct target_ops *target));
+
+static void remote_prepare_to_store PARAMS ((void));
+
+static void remote_fetch_registers PARAMS ((int regno));
+
+static void remote_resume PARAMS ((int pid, int step,
+				   enum target_signal siggnal));
+
+static int remote_start_remote PARAMS ((char *dummy));
+
+static void remote_open PARAMS ((char *name, int from_tty));
+
+static void extended_remote_open PARAMS ((char *name, int from_tty));
+
+static void remote_open_1 PARAMS ((char *, int, struct target_ops *));
+
+static void remote_close PARAMS ((int quitting));
+
+static void remote_store_registers PARAMS ((int regno));
+
+static void remote_mourn PARAMS ((void));
+
+static void extended_remote_restart PARAMS ((void));
+
+static void extended_remote_mourn PARAMS ((void));
+
+static void extended_remote_create_inferior PARAMS ((char *, char *, char **));
+
+static void remote_mourn_1 PARAMS ((struct target_ops *));
+
+static int getpkt PARAMS ((char **buf, int forever));
+
+static int putpkt PARAMS ((char *buf, int len));
+
+static void remote_send PARAMS ((char *buf));
+
+static int readchar PARAMS ((int timeout));
+
+static int remote_wait PARAMS ((int pid, struct target_waitstatus *status));
+
+static void remote_kill PARAMS ((void));
+
+static int tohex PARAMS ((int nib));
+
+static int fromhex PARAMS ((int a));
+
+static void remote_detach PARAMS ((char *args, int from_tty));
+
+static void remote_interrupt PARAMS ((int signo));
+
+static void remote_interrupt_twice PARAMS ((int signo));
+
+static void interrupt_query PARAMS ((void));
+
+static void remote_insert_wbreakpoint PARAMS ((CORE_ADDR addr));
+
+static void remote_remove_wbreakpoint PARAMS ((void));
+
+extern struct target_ops palmos_ops;	/* Forward decl */
+
+/* This was 5 seconds, which is a long time to sit and wait.
+   Unless this is going though some terminal server or multiplexer or
+   other form of hairy serial connection, I would think 2 seconds would
+   be plenty.  */
+
+static int remote_timeout = 2;
+
+static CORE_ADDR text_addr=0, data_addr=0, bss_addr=0;
+/*static struct Pilot_state state;*/
+
+#define MAX_BREAKS 5
+
+static struct {
+	unsigned long address;
+	int on;
+} breakpoint[MAX_BREAKS + 1];
+
+static char regs[REGISTER_BYTES];
+
+/* Portable memory access macros */
+
+#define get_long(ptr) ((((unsigned char*)(ptr))[0] << 24) | \
+                       (((unsigned char*)(ptr))[1] << 16) | \
+                       (((unsigned char*)(ptr))[2] << 8)  | \
+                       (((unsigned char*)(ptr))[3] << 0))
+
+#define get_treble(ptr) ((((unsigned char*)(ptr))[0] << 16) | \
+                         (((unsigned char*)(ptr))[1] << 8)  | \
+                         (((unsigned char*)(ptr))[2] << 0))
+
+#define get_short(ptr) ((((unsigned char*)(ptr))[0] << 8)  | \
+                        (((unsigned char*)(ptr))[1] << 0))
+
+#define get_byte(ptr) (((unsigned char*)(ptr))[0])
+
+#define set_long(ptr,val) ((((unsigned char*)(ptr))[0] = ((val) >> 24) & 0xff), \
+                          (((unsigned char*)(ptr))[1] = ((val) >> 16) & 0xff), \
+                          (((unsigned char*)(ptr))[2] = ((val) >> 8) & 0xff), \
+                          (((unsigned char*)(ptr))[3] = ((val) >> 0) & 0xff))
+
+#define set_treble(ptr,val) ((((unsigned char*)(ptr))[0] = ((val) >> 16) & 0xff), \
+                             (((unsigned char*)(ptr))[1] = ((val) >> 8) & 0xff), \
+                             (((unsigned char*)(ptr))[2] = ((val) >> 0) & 0xff))
+
+#define set_short(ptr,val) ((((unsigned char*)(ptr))[0] = ((val) >> 8) & 0xff), \
+                            (((unsigned char*)(ptr))[1] = ((val) >> 0) & 0xff))
+
+#define set_byte(ptr,val) (((unsigned char*)(ptr))[0]=(val))
+
+/* Following CRC code borrowed from xmodem.c */
+
+#define CRC16 0x1021		/* Generator polynomial (X^16 + X^12 + X^5 + 1) */
+
+static unsigned short *crctab;
+
+/* Call this to init the fast CRC-16 calculation table.  */
+
+static void
+crcinit ()
+{
+  static int crctab_inited = 0;
+  int val;
+
+  if (crctab_inited == 1)
+    return;
+
+  crctab = xmalloc (256 * sizeof (short));
+
+  for (val = 0; val <= 255; val++)
+    {
+      int i;
+      unsigned int crc;
+
+      crc = val << 8;
+
+      for (i = 0; i < 8; ++i)
+	{
+	  crc <<= 1;
+
+	  if (crc & 0x10000)
+	    crc ^= CRC16;
+	}
+
+      crctab [val] = crc;
+    }
+
+  crctab_inited = 1;
+}
+
+/* Calculate a CRC-16 for the LEN byte message pointed at by P.  */
+
+static unsigned short
+docrc (p, len)
+     unsigned char *p;
+     int len;
+{
+  unsigned short crc = 0;
+
+  while (len-- > 0)
+    crc = (crc << 8) ^ crctab [(crc >> 8) ^ *p++];
+
+  return crc;
+}
+
+  
+static void
+get_offsets ()
+{
+  struct section_offsets *offs;
+  
+  if (symfile_objfile == NULL)
+    return;
+    
+  if ((text_addr == 0) && (data_addr==0) && (bss_addr==0))
+    return;
+
+  offs = (struct section_offsets *) alloca (sizeof (struct section_offsets)
+					    + symfile_objfile->num_sections
+					    * sizeof (offs->offsets));
+  memcpy (offs, symfile_objfile->section_offsets,
+	  sizeof (struct section_offsets)
+	  + symfile_objfile->num_sections
+	  * sizeof (offs->offsets));
+
+  ANOFFSET (offs, SECT_OFF_TEXT) = text_addr;
+
+  /* This is a temporary kludge to force data and bss to use the same offsets
+     because that's what nlmconv does now.  The real solution requires changes
+     to the stub and remote.c that I don't have time to do right now.  */
+
+  ANOFFSET (offs, SECT_OFF_DATA) = data_addr;
+  ANOFFSET (offs, SECT_OFF_BSS) = data_addr;
+
+  objfile_relocate (symfile_objfile, offs);
+}
+
+/* Stub for catch_errors.  */
+
+static int
+remote_start_remote (dummy)
+     char *dummy;
+{
+     struct target_waitstatus status;
+  immediate_quit = 1;		/* Allow user to interrupt it */
+  
+  /*remote_wait(0,&status); /* Wait for remote to halt, hopefully fetching
+                             offsets in the process */
+
+  /*get_offsets ();		/* Get text, data & bss offsets */
+
+  immediate_quit = 0;
+
+  start_remote ();		/* Initialize gdb process mechanisms */
+  return 1;
+}
+
+/* Open a connection to a remote debugger.
+   NAME is the filename used for communication.  */
+
+static void
+remote_open (name, from_tty)
+     char *name;
+     int from_tty;
+{
+  remote_open_1 (name, from_tty, &palmos_ops);
+}
+
+/* Generic code for opening a connection to a remote target.  */
+static DCACHE *remote_dcache;
+
+static serial_t remote_desc = NULL;
+static int startup = 1;
+
+static void
+remote_open_1 (name, from_tty, target)
+     char *name;
+     int from_tty;
+     struct target_ops *target;
+{
+  if (name == 0)
+    error ("To open a remote debug connection, you need to specify what serial\n\
+device is attached to the remote system (e.g. /dev/ttya).");
+
+  target_preopen (from_tty);
+
+  unpush_target (target);
+
+  remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);
+
+  remote_desc = SERIAL_OPEN(name);
+  if (!remote_desc)
+    perror_with_name(name);
+    
+  if (baud_rate == -1)
+    baud_rate = 57600;
+
+  if (baud_rate != -1)
+    {
+    if (SERIAL_SETBAUDRATE (remote_desc, baud_rate))
+       {
+       SERIAL_CLOSE (remote_desc);
+       perror_with_name (name);
+      }
+  }
+  
+  SERIAL_RAW (remote_desc);
+  
+  crcinit();
+  
+  if (from_tty)
+    {
+      puts_filtered ("Remote debugging under PalmOS using ");
+      puts_filtered (name);
+      puts_filtered ("\n");
+      startup = 1;
+    }
+  push_target (target);	/* Switch to using remote target now */
+
+  inferior_pid = 42000;
+  /* Start the remote connection; if error (0), discard this target.
+     In particular, if the user quits, be sure to discard it
+     (we'd be in an inconsistent state otherwise).  */
+  if (!catch_errors (remote_start_remote, (char *)0, 
+		     "Couldn't establish connection to remote target\n", RETURN_MASK_ALL))
+    pop_target();
+}
+
+/* Clean up connection to a remote debugger.  */
+
+/* ARGSUSED */
+static void
+remote_close (quitting)
+     int quitting;
+{
+  if (remote_desc)
+    SERIAL_CLOSE(remote_desc);
+  remote_desc = NULL;
+}
+
+/* This takes a program previously attached to and detaches it.  After
+   this is done, GDB can be used to debug some other program.  We
+   better not have left any breakpoints in the target program or it'll
+   die when it hits one.  */
+
+static void
+remote_detach (args, from_tty)
+     char *args;
+     int from_tty;
+{
+  pop_target ();
+
+  if (from_tty)
+    puts_filtered ("Ending remote debugging.\n");
+}
+
+static enum target_signal last_sent_signal = TARGET_SIGNAL_0;
+int last_sent_step;
+
+static void
+remote_resume (pid, step, siggnal)
+     int pid, step;
+     enum target_signal siggnal;
+{
+   unsigned long sr;
+   unsigned short ins;
+   char buffer[90];
+   
+   buffer[0] = 0x07;
+   buffer[1] = 0;
+   memcpy(buffer+2, regs+REGISTER_BYTE(0), 60);    /* D0-D7, A0-A6 */
+   sr = get_long(regs+REGISTER_BYTE(16));
+   
+   if (step) {
+     remote_read_bytes (get_long(regs+REGISTER_BYTE(17)),
+				 (void *)&ins,
+				 2);
+
+     if (get_short(&ins) == 0x4e4f) {
+       remote_insert_wbreakpoint(get_long(regs+REGISTER_BYTE(17)) + 4);
+       sr &= 0x7FFF;
+     } else {
+       sr |= 0x8000;
+     }
+   } else {
+     sr &= 0x7FFF;
+   }
+
+   if (sr & 0x2000)
+     memcpy(buffer+66, regs+REGISTER_BYTE(15), 4); /* Store SSP */
+   else
+     memcpy(buffer+62, regs+REGISTER_BYTE(15), 4); /* Store USP */
+   memcpy(buffer+70, regs+REGISTER_BYTE(17), 4);   /* Store PC */
+   set_short(buffer+74, sr);   /* Store SR */
+   
+   memset(buffer+76, 0, 14); /* Zero out watch parameters */
+   
+   dcache_flush (remote_dcache);
+              
+   last_sent_signal = siggnal;
+   last_sent_step = step;
+   
+   putpkt(buffer, 90);
+}
+
+static void (*ofunc)();
+
+static void
+remote_interrupt (signo)
+     int signo;
+{
+  char buffer[10];
+  signal (signo, remote_interrupt_twice);
+  
+  fputs_filtered ("Sending query. (Press Ctrl-C again to give up)\n", gdb_stdout);
+  
+  buffer[0] = 0;
+  buffer[1] = 0;
+  putpkt(buffer, 2);
+}
+
+static void
+remote_interrupt_twice (signo)
+     int signo;
+{
+  signal (signo, ofunc);
+  
+  interrupt_query ();
+
+  signal (signo, remote_interrupt);
+}
+
+/* Ask the user what to do when an interrupt is received.  */
+
+static void
+interrupt_query ()
+{
+  target_terminal_ours ();
+
+  if (query ("Interrupted while waiting for the program.\n\
+Give up (and stop debugging it)? "))
+    {
+      target_mourn_inferior ();
+      return_to_top_level (RETURN_QUIT);
+    }
+
+  target_terminal_inferior ();
+}
+
+static long computeSignal( long exceptionVector )
+{
+  long sigval;
+
+  switch (exceptionVector) {
+    case 2 : sigval = 10; break; /* bus error           */
+    case 3 : sigval = 10; break; /* address error       */
+    case 4 : sigval = 4;  break; /* illegal instruction */
+    case 5 : sigval = 8;  break; /* zero divide         */
+    case 6 : sigval = 8; break; /* chk instruction     */
+    case 7 : sigval = 8; break; /* trapv instruction   */
+    case 8 : sigval = 11; break; /* privilege violation */
+    case 9 : sigval = 5;  break; /* trace trap          */
+    case 10: sigval = 4;  break; /* line 1010 emulator  */
+    case 11: sigval = 4;  break; /* line 1111 emulator  */
+
+      /* Coprocessor protocol violation.  Using a standard MMU or FPU
+	 this cannot be triggered by software.  Call it a SIGBUS.  */
+    case 13: sigval = 10;  break;
+
+    case 31: sigval = 2;  break; /* interrupt           */
+    case 32: sigval = 5;  break; /* breakpoint          */
+
+      /* This is a trap #8 instruction.  Apparently it is someone's software
+	 convention for some sort of SIGFPE condition.  Whose?  How many
+	 people are being screwed by having this code the way it is?
+	 Is there a clean solution?  */
+    case 40: sigval = 8;  break; /* floating point err  */
+
+    case 48: sigval = 8;  break; /* floating point err  */
+    case 49: sigval = 8;  break; /* floating point err  */
+    case 50: sigval = 8;  break; /* zero divide         */
+    case 51: sigval = 8;  break; /* underflow           */
+    case 52: sigval = 8;  break; /* operand error       */
+    case 53: sigval = 8;  break; /* overflow            */
+    case 54: sigval = 8;  break; /* NAN                 */
+    default: 
+      sigval = 7;         /* "software generated"*/
+  }
+  return (sigval);
+}
+
+/* If nonzero, ignore the next kill.  */
+int kill_kludge;
+
+/* Read a single character from the remote end. */
+
+static int
+readchar (timeout)
+     int timeout;
+     {
+       int ch;
+       
+       ch = SERIAL_READCHAR (remote_desc, timeout);
+         
+       switch (ch)
+         {
+         case SERIAL_EOF:
+          error ("Remote connection closed");
+         case SERIAL_ERROR:
+         perror_with_name ("Remote communication error");
+       case SERIAL_TIMEOUT:
+       return ch;
+     default:
+        return ch;
+      }
+}
+
+/* Wait until the remote machine stops, then return,
+   storing status in STATUS just as `wait' would.
+   Returns "pid" (though it's not clear what, if anything, that
+   means in the case of this target).  */
+
+static int
+remote_wait (pid, status)
+     int pid;
+     struct target_waitstatus *status;
+{
+  char * buf;
+  int len;
+  int thread_num = -1;
+  unsigned long ins;
+  
+  if (startup) {
+    fputs_filtered ("Waiting... (Press Ctrl-C to connect to halted machine)\n", gdb_stdout);
+    startup = 0;
+  }
+  	
+  status->kind = TARGET_WAITKIND_EXITED;
+    status->value.integer = 0;
+	    
+	while (1) {
+	   ofunc = (void (*)()) signal (SIGINT, remote_interrupt);
+  	   len = getpkt(&buf, 1);
+  	   signal (SIGINT, ofunc);
+  	   
+  	   if (len<10) /* Reception failed, skip */
+  	     continue;
+  	   
+  	   if ((buf[3] != 0) || (buf[4] != 0) || (buf[5] != 0))
+  	     /* Not a debugging packet, skip */
+  	     continue;
+  	   
+	  if (buf[10] == (char)0x7F) { /* Message */
+	      int i;
+	      for (i=12;i<len;i++) {
+	        if (buf[i] == '\r')
+	          buf[i] = '\n';
+	      }
+	      buf[len] = 0;
+              if (target_output_hook)
+	       target_output_hook (buf+12);
+	      else
+	        fputs_filtered (buf+12, gdb_stdout);
+	      continue;
+	  }
+	  else if (buf[10] == (char)0x80) { /* Break & state */
+	    unsigned long sr;
+	    int i;
+
+#define State_exception 14
+#define State_D0 16
+#define State_D1 20
+#define State_D2 24
+#define State_D3 28
+#define State_A0 48
+#define State_USP 76
+#define State_SSP 80
+#define State_PC 84
+#define State_SR 88
+#define State_INS State_SR+30
+#define Breakpoint_0 State_SR+2+30
+
+	    
+	    status->kind = TARGET_WAITKIND_STOPPED;
+	    status->value.sig = computeSignal(get_short(buf+State_exception)/4);
+	    
+	    memcpy(regs+REGISTER_BYTE(0), buf+State_D0, 60); /* D0-D7, A0-A6 */
+	    
+	    sr = get_short(buf+State_SR);
+	    if (sr & 0x2000) /* Check supervisor bit */
+	      memcpy(regs+REGISTER_BYTE(15), buf+State_SSP, 4); /* SSP */
+	    else
+	      memcpy(regs+REGISTER_BYTE(15), buf+State_USP, 4); /* USP */
+	    
+	    set_long(regs+REGISTER_BYTE(16), sr); /* SR */
+	    memcpy(regs+REGISTER_BYTE(17), buf+State_PC, 4); /* PC */
+	    
+	    for (i=0;i<6;i++) {
+	      breakpoint[i].address = get_long(buf+Breakpoint_0+i*6);
+	      breakpoint[i].on = get_byte(buf+Breakpoint_0+4+i*6);
+	    }
+
+	    if (get_long(buf+State_PC) == breakpoint[MAX_BREAKS].address) {
+	      remote_remove_wbreakpoint();
+	    }
+	    
+	    if ((get_short(buf+State_exception) == 40 *4) &&
+		(get_long(buf+State_D3) == 0x12BEEF34)) {
+
+#if 0
+  	      puts_filtered ("Got target position.\n");
+#endif
+	      text_addr = get_long(buf+State_D0);
+	      bss_addr =  get_long(buf+State_D1);
+	      data_addr = get_long(buf+State_D2);
+              remote_insert_wbreakpoint(get_long(buf+State_A0) + 4);
+	      get_offsets();
+              remote_resume(0,0,TARGET_SIGNAL_0);
+	      stop_soon_quietly = 0;
+              continue;
+	    }
+	    break;
+	    
+	  }
+  	  puts_filtered ("Unknown packet received.\n");
+	}
+	return inferior_pid;
+}
+
+/* Number of bytes of registers this stub implements.  */
+static int register_bytes_found;
+
+/* Read the remote registers into the block REGS.  */
+/* Currently we just read all the registers, so we don't use regno.  */
+/* ARGSUSED */
+static void
+remote_fetch_registers (regno)
+     int regno;
+{
+  int i;
+  unsigned long sr;
+  
+  for (i = 0; i < NUM_REGS; i++)
+      supply_register (i, &regs[REGISTER_BYTE(i)]);
+}
+
+/* Prepare to store registers.  Since we may send them all (using a
+   'G' request), we have to read out the ones we don't want to change
+   first.  */
+
+static void 
+remote_prepare_to_store ()
+{
+  /* no-op, registers are automatic retrieved */
+  return;
+}
+
+/* Store register REGNO, or all registers if REGNO == -1, from the contents
+   of REGISTERS.  FIXME: ignores errors.  */
+
+static void
+remote_store_registers (regno)
+     int regno;
+{
+  int i;
+  for (i = 0; i < NUM_REGS; i++)
+      if ((regno==-1) || (i == regno))
+          memcpy(&regs[REGISTER_BYTE(i)], &registers[REGISTER_BYTE(i)], 4);
+}
+
+/* 
+   Use of the data cache *used* to be disabled because it loses for looking at
+   and changing hardware I/O ports and the like.  Accepting `volatile'
+   would perhaps be one way to fix it.  Another idea would be to use the
+   executable file for the text segment (for all SEC_CODE sections?
+   For all SEC_READONLY sections?).  This has problems if you want to
+   actually see what the memory contains (e.g. self-modifying code,
+   clobbered memory, user downloaded the wrong thing).  
+
+   Because it speeds so much up, it's now enabled, if you're playing
+   with registers you turn it of (set remotecache 0)
+*/
+
+/* Read a word from remote address ADDR and return it.
+   This goes through the data cache.  */
+
+#if 0	/* unused? */
+static int
+remote_fetch_word (addr)
+     CORE_ADDR addr;
+{
+  return dcache_fetch (remote_dcache, addr);
+}
+
+/* Write a word WORD into remote address ADDR.
+   This goes through the data cache.  */
+
+static void
+remote_store_word (addr, word)
+     CORE_ADDR addr;
+     int word;
+{
+  dcache_poke (remote_dcache, addr, word);
+}
+#endif	/* 0 (unused?) */
+
+
+/* Write memory data directly to the remote machine.
+   This does not inform the data cache; the data cache uses this.
+   MEMADDR is the address in the remote memory space.
+   MYADDR is the address of the buffer in our space.
+   LEN is the number of bytes.
+
+   Returns number of bytes transferred, or 0 for error.  */
+
+static int
+remote_write_bytes (memaddr, myaddr, len)
+     CORE_ADDR memaddr;
+     char *myaddr;
+     int len;
+{
+	char buffer[280];
+	char * ret;
+	int l;
+	unsigned long todo, done;
+	
+	printf("wanting to write %d bytes at %d\n", len, memaddr);
+	
+	done = 0;
+	while (done < len) {
+	  todo = (len-done);
+	  if (todo > 256)
+	    todo = 256;
+	  
+	  buffer[0] = 0x02;
+	  buffer[1] = 0;
+	  set_long(buffer+2, memaddr + done);
+	  set_short(buffer+6, todo);
+	  
+	  memcpy(buffer+8, myaddr+done, todo);
+	  
+	  putpkt(buffer, 8 + todo);
+	  
+	  if (getpkt(&ret, 0) != 12) {
+	    break;
+	  }
+	  done += todo;
+	}
+	printf("Actually wrote %d bytes\n", done);
+	return done;
+}
+
+/* Read memory data directly from the remote machine.
+   This does not use the data cache; the data cache uses this.
+   MEMADDR is the address in the remote memory space.
+   MYADDR is the address of the buffer in our space.
+   LEN is the number of bytes.
+
+   Returns number of bytes transferred, or 0 for error.  */
+
+static int
+remote_read_bytes (memaddr, myaddr, len)
+     CORE_ADDR memaddr;
+     char *myaddr;
+     int len;
+{
+	char buffer[8];
+	char * ret;
+	unsigned long todo, done;
+	
+	done = 0;
+	while (done < len) {
+	  todo = (len-done);
+	  if (todo > 256)
+	    todo = 256;
+	  
+	  buffer[0] = 0x01;
+	  buffer[1] = 0;
+	  set_long(buffer+2, memaddr + done);
+	  set_short(buffer+6, todo);
+	  
+	  putpkt(buffer, 8);
+	  
+	  if (getpkt(&ret, 0) == todo+12) {
+	    memcpy(myaddr+done, ret+12, todo);
+	  } else {
+	    break;
+	  }
+	  done += todo;
+	}
+	return done;
+}
+
+/* Read or write LEN bytes from inferior memory at MEMADDR, transferring
+   to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is
+   nonzero.  Returns length of data written or read; 0 for error.  */
+
+/* ARGSUSED */
+static int
+remote_xfer_memory(memaddr, myaddr, len, should_write, target)
+     CORE_ADDR memaddr;
+     char *myaddr;
+     int len;
+     int should_write;
+     struct target_ops *target;			/* ignored */
+{
+  return dcache_xfer_memory (remote_dcache, memaddr, myaddr, len, should_write);
+}
+
+   
+#if 0
+/* Enable after 4.12.  */
+
+void
+remote_search (len, data, mask, startaddr, increment, lorange, hirange
+	       addr_found, data_found)
+     int len;
+     char *data;
+     char *mask;
+     CORE_ADDR startaddr;
+     int increment;
+     CORE_ADDR lorange;
+     CORE_ADDR hirange;
+     CORE_ADDR *addr_found;
+     char *data_found;
+{
+}
+#endif /* 0 */
+
+static void
+remote_files_info (ignore)
+     struct target_ops *ignore;
+{
+  puts_filtered ("Debugging a target over a serial line.\n");
+}
+
+static unsigned char transid = 0x11;
+
+/* Send a packet to the remote machine.
+   The data of the packet is in BUF.  */
+
+static int
+putpkt (buf, len)
+     char *buf;
+     int len;
+{
+  static unsigned char buffer[0xffff];
+  int i;
+  
+  buffer[0] = 0xBE;
+  buffer[1] = 0xEF;
+  buffer[2] = 0xED;
+  buffer[3] = 0;
+  buffer[4] = 0;
+  buffer[5] = 0;
+  buffer[6] = len >> 8;
+  buffer[7] = len & 0xff;
+  buffer[8] = ++transid;
+  buffer[9] = 0;
+  for (i=0;i<9;i++)
+    buffer[9] += buffer[i];
+  
+  memcpy(buffer+10, buf, len);
+  
+  set_short(buffer+len+10, docrc(buffer, len+10));
+  
+  /*printf("Sending: ");
+  for (i=0;i<len+12;i++) {
+     printf("%.2X ", buffer[i]);
+  }
+  printf("!\n");*/
+   
+  if (SERIAL_WRITE(remote_desc, buffer, len+12))
+         perror_with_name ("putpkt: write failed");
+}
+
+/* Read a packet from the remote machine, with error checking,
+   and store it in BUF.  BUF is expected to be of size PBUFSIZ.
+   If FOREVER, wait forever rather than timing out; this is used
+   while the target is executing user code.  */
+
+static int
+getpkt (buf, forever)
+     char **buf;
+     int forever;
+{
+  static unsigned char buffer[0xffff];
+  int state = 0;
+  int c;
+  int i;
+  unsigned int src, dest, type, len, csum, crc;
+  
+  while(1) {
+    c = readchar(-1);
+    if (c == SERIAL_TIMEOUT) {
+       if (!forever)
+          return 0;
+    }
+    
+    buffer[state] = c;
+    
+    switch (state) {
+    	case 0:
+    	    if (c == 0xBE) state++; else state=0;
+    	    break;
+    	case 1:
+    	    if  (c == 0xEF) state++; else state=0; 
+    	    break;
+    	case 2:
+    	    if  (c == 0xED) state++; else state=0;
+    	    break;
+    	case 3:
+    	case 4:
+    	case 5:
+    	case 6:
+    	case 7:
+    	case 8:
+    	    state++;
+    	    break;
+    	case 9:
+    	    csum = 0;
+    	    for (i=0;i<9;i++)
+    	      csum += buffer[i];
+    	    if ((csum & 0xff) == c) {
+    	      len = (buffer[6] << 8) | buffer[7];
+    	      state++;
+    	    }
+    	    else
+    	      state=0;
+    	    break;
+    	default:
+    	    if (state >= 10) {
+    	      if (state < 10+len) {
+    	        state++;
+    	      } 
+    	      else if (state == 10+len) {
+    	        crc = c;
+    	        state++;
+    	      } else if (state == 11+len) {
+    	        unsigned long mycrc = docrc(buffer,len+10);
+    	        crc = (crc<<8)|c;
+    	        if ((crc & 0xffff) == mycrc) {
+    	           *buf = buffer;
+    	           return len+10;
+    	        } else 
+    	          state = 0;
+    	      } else
+    	        state = 0;
+    	    } else
+    	      state = 0;
+       }
+       
+  }
+}
+
+static void
+remote_kill ()
+{
+  char buffer[96];
+
+  /* For some mysterious reason, wait_for_inferior calls kill instead of
+     mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
+  if (kill_kludge)
+    {
+      kill_kludge = 0;
+      target_mourn_inferior ();
+      return;
+    }
+    
+  /* Warm boot the Pilot */
+  
+  buffer[0] = 0x0A;
+  buffer[1] = 0;
+  set_short(buffer+2, 0xA08C); /* SysReboot */
+  set_long(buffer+4, 0); /*D0*/
+  set_long(buffer+8, 0); /*A0*/
+  set_short(buffer+12, 0); /* No parameters */
+  
+  putpkt(buffer, 14);
+
+  /* Don't wait for it to die.  I'm not really sure it matters whether
+     we do or not.  For the existing stubs, kill is a noop.  */
+  target_mourn_inferior ();
+}
+
+static void
+remote_mourn ()
+{
+  unpush_target (&palmos_ops);
+  generic_mourn_inferior ();
+}
+
+
+
+/* Note: we must use native breakpoint support, as code segments are in
+   write-protected memory, and thus cannot easily have breaks written
+   over them. */
+
+/* Send breakpoint structure to the Pilot. Return non-zero on error */
+
+static int
+set_breakpoints()
+{
+  int i;
+  char buffer[90];
+  char * ret;
+  
+  buffer[0] = 0x0c;
+  buffer[1] = 0;
+  
+  for(i=0;i<6;i++) {
+    set_long(buffer+2+i*6, breakpoint[i].address);
+    set_byte(buffer+2+4+i*6, breakpoint[i].on);
+    set_byte(buffer+2+5+i*6, 0);
+  }
+  
+  putpkt(buffer, 38);
+  
+  if (i = getpkt(&ret, 0)) {
+    return ((unsigned char)ret[10] != (unsigned char)0x8c) || (i != 12);
+  }
+  return 1;
+}
+
+static int
+remote_insert_breakpoint (addr, contents_cache)
+     CORE_ADDR addr;
+     char *contents_cache;
+{
+  int i;
+  for (i=0;i<MAX_BREAKS;i++)
+    if (breakpoint[i].on == 0)
+      break;
+  if (i < MAX_BREAKS) {
+    breakpoint[i].address = addr;
+    breakpoint[i].on = 1;
+    return set_breakpoints();
+  } else {
+        fprintf_filtered (gdb_stderr,
+        "Too many break points, break point not installed\n");
+       return (1);
+  }                            
+}
+
+static int
+remote_remove_breakpoint (addr, contents_cache)
+     CORE_ADDR addr;
+     char *contents_cache;
+{
+  int i;
+  for (i=0;i<MAX_BREAKS;i++)
+    if (breakpoint[i].on && breakpoint[i].address == addr)
+      break;
+  if (i<MAX_BREAKS) {
+    breakpoint[i].address = 0;
+    breakpoint[i].on = 0;
+    return set_breakpoints();
+  }
+  
+  return 0;
+}
+
+static void
+remote_insert_wbreakpoint (addr)
+     CORE_ADDR addr;
+{
+  breakpoint[MAX_BREAKS].address = addr;
+  breakpoint[MAX_BREAKS].on = 1;
+#if 0
+  stop_soon_quietly = 1;  /* gdb is making a mess of this stuff */
+  stop_after_trap = 1;
+#endif
+  set_breakpoints();
+}
+
+static void
+remote_remove_wbreakpoint ()
+{
+  breakpoint[MAX_BREAKS].address = 0;
+  breakpoint[MAX_BREAKS].on = 0;
+  set_breakpoints();
+}
+
+
+/* Define the target subroutine names */
+
+struct target_ops palmos_ops = {
+  "pilot",			/* to_shortname */
+  "Remote serial target in PalmOS/Pilot-specific protocol",	/* to_longname */
+  "Use Palm Pilot via a serial line, using a PalmOS-specific protocol.\n\
+Specify the serial device it is connected to (e.g. /dev/ttya).",  /* to_doc */
+  remote_open,			/* to_open */
+  remote_close,			/* to_close */
+  NULL,				/* to_attach */
+  remote_detach,		/* to_detach */
+  remote_resume,		/* to_resume */
+  remote_wait,			/* to_wait */
+  remote_fetch_registers,	/* to_fetch_registers */
+  remote_store_registers,	/* to_store_registers */
+  remote_prepare_to_store,	/* to_prepare_to_store */
+  remote_xfer_memory,		/* to_xfer_memory */
+  remote_files_info,		/* to_files_info */
+  remote_insert_breakpoint,	/* to_insert_breakpoint */
+  remote_remove_breakpoint,	/* to_remove_breakpoint */
+  NULL,				/* to_terminal_init */
+  NULL,				/* to_terminal_inferior */
+  NULL,				/* to_terminal_ours_for_output */
+  NULL,				/* to_terminal_ours */
+  NULL,				/* to_terminal_info */
+  remote_kill,			/* to_kill */
+  generic_load,			/* to_load */
+  NULL,				/* to_lookup_symbol */
+  NULL,				/* to_create_inferior */
+  remote_mourn,			/* to_mourn_inferior */
+  0,				/* to_can_run */
+  0,				/* to_notice_signals */
+  0,				/* to_thread_alive */
+  0,				/* to_stop */
+  process_stratum,		/* to_stratum */
+  NULL,				/* to_next */
+  1,				/* to_has_all_memory */
+  1,				/* to_has_memory */
+  1,				/* to_has_stack */
+  1,				/* to_has_registers */
+  1,				/* to_has_execution */
+  NULL,				/* sections */
+  NULL,				/* sections_end */
+  OPS_MAGIC			/* to_magic */
+};
+
+void
+_initialize_pilot ()
+{
+  add_target (&palmos_ops);
+}
diff -urN orig/gdb-4.16/gdb/ser-unix.c gdb-4.16/gdb/ser-unix.c
--- orig/gdb-4.16/gdb/ser-unix.c	Thu Sep 28 20:13:39 1995
+++ gdb-4.16/gdb/ser-unix.c	Sat Jun 14 13:27:08 1997
@@ -579,6 +579,18 @@
   {9600, B9600},
   {19200, B19200},
   {38400, B38400},
+#ifdef B57600
+  {57600, B57600},
+#endif
+#ifdef B115200
+  {115200, B115200},
+#endif
+#ifdef B230400
+  {230400, B230400},
+#endif
+#ifdef B460800
+  {460800, B460800},
+#endif
   {-1, -1},
 };
 
